---
layout: default
title: interact with data
---
<style>
	.acc { 
		fill:rgba(230, 102, 102, 1); 
	}
	.natur { 
		fill:rgba(102, 230, 172, 1); 
	}

	body{
		background-color: #000A17;
	}
	svg {
		background-color: #000A17;
	}
	
    #donutHolder{
    	position: absolute;
    	right:200px;
    	top:150px;
    	text-align: center;
	}
    #donutHolder h2{
	    	color:white;
		    font-size: 28px;
		    line-height: 40px;
		    margin: 0 0 15px 0;
		    width: 500px;
	 }
	 .labels{
		color: white;
		cursor: pointer;
		width: 400px;
	}
	#donutHolder .labels h2 {
	    font-size: 18px;
	    line-height: 24px;
	    margin: 0 0 0 40px;
	    text-align: left;
    }
    #donutHolder .labels #natural{
    	color: rgba(102, 230, 172, 1); 
    }
    #donutHolder .labels #nonnatural{
    	color: rgba(230, 102, 102, 1); 
    }
    #total{
    	position: absolute;
    	text-align: center;
    	top:185px;
    	width: 100%;
    }
</style>
<div id="donutHolder">
<h2>
	Death by Zip Code in California
</h2>
<h2 id="total"></h2>
<svg id="donut" width="300px" height="300px"></svg>
<div class="labels">
	<h2 id="natural">natural</h2>
	<h2 id="nonnatural">nonnatural</h2>
</div>

</div>
<!--h1>
	this is bad
</h1-->
<select id="yearDropdown">
</select>
<script type="text/javascript">
	var raw_data = [];
	var raw_data2 = [];
	var yearData = [];
	var yearValues = [];
	var yearCounts = [];
	var years = [];
	var nestedByYear = [];
	var nestedByZip = [];
	var maxCount = -1;
	var maxCount2 = -1;
	var maxCount3 = -1;
	var countPercent = [];
	var col = 1;
	var countZips = [];
	var countIndex = - 1;
	var nestedNat = [];
	var nestedNonNat = [];
	var nestedNatPercent = [];
	var nestedNonNatPercent = [];
	var natCount = 0;
	var nonNatCount = 0;
	var natCount = 0;
	var nonNatCount = 0;
	var drawNatural = true;
	var counts = 100;
	var counts2 = 10;
	var nope = [];

	d3.csv("/data/Leading_Causes_of_Death_by_ZIP_Code__1999-2013.csv", function(error, data){
		raw_data = data.filter(function(d){
			return d.ZIP === "94110";
		});

		nestedByYear = d3.nest()
		.key(function(d) {
			return d.Year;
		})
		.entries(data);

		yearData = d3.nest()
		.key(function(d) {
			return d.Year;
		})
		.entries(raw_data);

		raw_data.forEach(function(d){
			d.year = parseFloat(d.Year);
			if ( years.indexOf(d.year) == -1) {
				return years.push(d.year);
			}
		});

		// years.sort();
		year = years[0];

		d3.select("#yearDropdown").selectAll("option")
		.data(years).enter().append("option")
		.attr("value", function(d){
			return d;
		})
		.text(function(d){
			return d;
		});

		d3.select("#yearDropdown").on("change", function(d){
			year = years[this.selectedIndex]
			yearValues = yearData[this.selectedIndex]
			yearCounts = [];
			yearValues.values.forEach(function(d){
				return yearCounts.push(d);
			}); 

			counts = 0;
			counts2 = 0;

			currentYear = nestedByYear[this.selectedIndex];
			console.log(currentYear);

			nestedByZip = [];
			nestedByZip = d3.nest()
			.key(function(d) {
				return d.ZIP;
			})
			.rollup(function(leaves) { 
				var num = 0;
				var no = [];
				leaves.forEach(function(d){
					return   no.push(parseFloat(d.Count));
				}); 
				return no.reduce(function(a, b) {
					return a + b;
				});
			})
			.entries(currentYear.values);

			nestedNonNat = d3.nest()
			.key(function(d) {
				return d.ZIP;
			})
			.rollup(function(leaves) { 
				var num = 0;
				var no = [];
				leaves.forEach(function(d){
					if(d.Causes_of_Death == "SUI" || 
						d.Causes_of_Death == "HOM" || 
						d.Causes_of_Death == "INJ") {
					return  no.push(parseFloat(d.Count))};
				}); 
				return no.reduce(function(a, b) {
					return a + b;
				});
			})
			.entries(currentYear.values);


			nestedNat = d3.nest()
			.key(function(d) {
				return d.ZIP;
			})
			.rollup(function(leaves) { 
				var num = 0;
				var no = [];
				leaves.forEach(function(d){
					if(d.Causes_of_Death != "SUI" && 
						d.Causes_of_Death != "HOM" && 
						d.Causes_of_Death != "INJ") {
					return  no.push(parseFloat(d.Count))};
				}); 
				return no.reduce(function(a, b) {
					return a + b;
				});
			})
			.entries(currentYear.values);

			// sum of natural deaths
			nestedNat.forEach(function(d){
				counts = counts + d.values;
			});

			natCount = counts;

			// sum of natural deaths
			nestedNonNat.forEach(function(d){
				counts2 = counts2 + d.values;
			});

			nonNatCount = counts2;

			maxCount = -1;
			maxCount2 = -1;
			maxCount3 = -1;

			nestedByZip.forEach(function(d){
				if (d.values > maxCount) {
					maxCount = d.values;
				}
			});

			nestedNat.forEach(function(d){
				if (d.values > maxCount2) {
					maxCount2 = d.values;
				}
			});

			nestedNonNat.forEach(function(d){
				if (d.values > maxCount3) {
					maxCount3 = d.values;
				}
			});
			nestedNat.forEach(function(d){
				d.values = d.values/maxCount2;
			});
			nestedNonNat.forEach(function(d){
				d.values = d.values/maxCount3;
			});

			countPercent = nestedByZip;
			countPercent.forEach(function(d){
				d.values = d.values/maxCount;
			});
			countZips = [];
			countPercent.forEach(function(d){
				return countZips.push(d.key)
			});

			console.log(maxCount);
			console.log(countPercent);

			nestedByZip = nestedByZip.reduce(function(obj,  d) {
				obj[d.key] = d.values;
				return obj;
			}, {});

		    nestedNatPercent = nestedNat.reduce(function(obj,  d) {
				obj[d.key] = d.values;
				return obj;
			}, {});

		    nestedNonNatPercent = nestedNonNat.reduce(function(obj,  d) {
				obj[d.key] = d.values;
				return obj;
			}, {});
			// console.log(colScale(maxCount));

			d3.select("#natural").on("mousedown", function(d){
				drawNatural = true;
				draw(nestedNatPercent)
			});

			d3.select("#nonnatural").on("mousedown", function(d){
				drawNatural = false;
				draw(nestedNonNatPercent)
			});

			nope = [
				{"color" : "rgba(102, 230, 172, 1)", "count" : natCount},
				{"color" : "rgba(230, 102, 102, 1)", "count" : nonNatCount}
				];

			d3.select("#total")
				.html(nonNatCount + natCount);

			drawDonut(nope);
			delegatDraw();
		});

});

var width = "800";
var height = "1000";
var rawData = [];
var zipList = [];
var years2 = [];

var svg = d3.select("body").append("svg")
.attr("width", width)
.attr("height", height);


var colScale = d3.scale.linear()
.domain([0.0, 1.0])
.range([0.25, 1.0]);
var featureCollection = "";

d3.json("data/ca_zip.json", function(error, data) {
	console.log(data);

	featureCollection = topojson.feature(data, data.objects.zip_codes_for_the_usa);
});

function delegatDraw() {
	if (drawNatural) {
		draw(nestedNatPercent);
	}
	if (!drawNatural) {
		draw(nestedNonNatPercent);
	}
}
function draw(data) {


	var center = d3.geo.centroid(featureCollection)
	var scale  = 150;
	var offset = [width/2, height/2];
	var proj = d3.geo.mercator().scale(scale).center(center)
	.translate(offset);

		// create the path
		var path = d3.geo.path().projection(proj);

		// using the path determine the bounds of the current map and use 
		// these to determine better values for the scale and translation
		var bounds  = path.bounds(featureCollection);
		var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
		var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
		var scale   = (hscale < vscale) ? hscale : vscale;
		var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
		height - (bounds[0][1] + bounds[1][1])/2];

        // console.log(center, scale, offset)

		// new projection
		proj = d3.geo.mercator().center(center)
		.scale(scale).translate(offset);
		path = path.projection(proj);

		var paths = svg.selectAll("path")
		.data(featureCollection.features, function(d){
			return d.properties.zip;
		});

		paths.enter().append("path")
		.attr("d", path)
		.attr("fill",  function(d) {
			if (drawNatural){
				return "rgba(102, 230, 172, 1)";
			}
			else return "rgba(230, 102, 102, 1)";
		})
		.attr("opacity", 0.01);

		var size = 0;
		paths.transition().duration(500)
		.attr("fill", function(d) {
			if (drawNatural){
				return "rgba(102, 230, 172, 1)";
			}
			else return "rgba(230, 102, 102, 1)";
		})
		.attr("opacity", function(d){
			if(d.properties.zip in nestedByZip) {
				size = size + 1;
				return colScale(nestedByZip[d.properties.zip]);
			}
			else {
				return 0.1;
			}
		})
		.delay(function(d, i){
			return i / size * 1000;
		})
		.duration(250);

		paths.on("mouseover", function(d){
			d3.select(this).transition().duration(50)
			.attr("opacity", function(d){
				if(d.properties.zip in nestedByZip) {
					return colScale(nestedByZip[d.properties.zip]) + .4;
				}
				else {
					return 0.1;
				}
			})
		});

		paths.on("mouseout", function(d){
			d3.select(this).transition().duration(800)
			.attr("opacity", function(d){
				if(d.properties.zip in nestedByZip) {
					return colScale(nestedByZip[d.properties.zip]);
				}
				else {
					return 0.1;
				}
			})
		});

		paths.exit()
		.attr("opacity", "0")
		.remove()
		.transition().duration(800);	
	}


  ///////////////
 //   donut   //
///////////////

function drawDonut(data){


	var pie = d3.layout.pie()
		.value(function(d){
			return d.count;
		});

	data = pie(data);

	var arc = d3.svg.arc()
		.innerRadius(100)
		.outerRadius(150);

	var slices = d3.select("#donut").selectAll("path")
		.data(data);

	slices.enter().append("path")
		.attr("transform", "translate(150, 150)")
		.style("fill", function(d){
			return d.data.color;
		})
		.attr("d", arc);

	slices.transition().duration(500);

	slices.exit().remove();

	}

    // var value = this.value;
    // clearTimeout(timeout);
    // pie.value(function(d) { return d[value]; }); // change the value function
    // path = path.data(pie); // compute the new angles
    // path.transition().duration(750).attrTween("d", arcTween); // redraw the arcs

</script>