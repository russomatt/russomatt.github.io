---
layout: default
title: interact with data
---
<style>
	.acc { 
		fill:rgba(247, 251, 255, 1); 
	}
	.natur { 
		fill:rgba(102, 230, 172, 1); 
	}

	body{
		background-color: #000A17;
	}
	svg {
		background-color: #000A17;
	}
</style>
<!--h1>
	this is bad
</h1-->
<select id="yearDropdown">
</select>
<script type="text/javascript">
	var raw_data = [];
	var raw_data2 = [];
	var yearData = [];
	var yearValues = [];
	var yearCounts = [];
	var years = [];
	var nestedByYear = [];
	var nestedByZip = [];
	var maxCount = -1;
	var countPercent = [];
	var col = 1;
	var countZips = [];
	var countIndex = - 1;

	d3.csv("/data/Leading_Causes_of_Death_by_ZIP_Code__1999-2013.csv", function(error, data){
		raw_data = data.filter(function(d){
			return d.ZIP === "94110";
		});

		nestedByYear = d3.nest()
		.key(function(d) {
			return d.Year;
		})
		.entries(data);

		yearData = d3.nest()
		.key(function(d) {
			return d.Year;
		})
		.entries(raw_data);

		// console.log(yearData[0].values.length);

		raw_data.forEach(function(d){
			d.year = parseFloat(d.Year);
			if ( years.indexOf(d.year) == -1) {
				return years.push(d.year);
			}
		});

		// years.sort();
		year = years[0];

		d3.select("#yearDropdown").selectAll("option")
		.data(years).enter().append("option")
		.attr("value", function(d){
			return d;
		})
		.text(function(d){
			return d;
		});

		d3.select("#yearDropdown").on("change", function(d){
			year = years[this.selectedIndex]
			yearValues = yearData[this.selectedIndex]
			yearCounts = [];
			yearValues.values.forEach(function(d){
				return yearCounts.push(d);
			}); 

			currentYear = nestedByYear[this.selectedIndex];
			console.log(currentYear);

			nestedByZip = [];
			nestedByZip = d3.nest()
			.key(function(d) {
				return d.ZIP;
			})
			.rollup(function(leaves) { 
				var num = 0;
				var no = [];
				leaves.forEach(function(d){
					return   no.push(parseFloat(d.Count));
				}); 
				return no.reduce(function(a, b) {
					return a + b;
				});
			})
			.entries(currentYear.values);

			maxCount = -1;

			nestedByZip.forEach(function(d){
				if (d.values > maxCount) {
					maxCount = d.values;
				}
			});

			countPercent = nestedByZip;
			countPercent.forEach(function(d){
				d.values = d.values/maxCount;
			});
			countZips = [];
			countPercent.forEach(function(d){
				return countZips.push(d.key)
			});

			// var currentCount = this.values

			console.log(maxCount);
			console.log(countPercent);
			nestedByZip = nestedByZip.reduce(function(obj,  d) {
				obj[d.key] = d.values;
				return obj;
			}, {})
			// console.log(colScale(maxCount));

			draw(nestedByZip)
		});

});

var width = "800";
var height = "1000";
var rawData = [];
var zipList = [];
var years2 = [];

var svg = d3.select("body").append("svg")
.attr("width", width)
.attr("height", height);


var colScale = d3.scale.linear()
.domain([0.0, 1.0])
.range([0.05, 1.0]);
var featureCollection = "";

d3.json("data/ca_zip.json", function(error, data) {
	console.log(data);

	featureCollection = topojson.feature(data, data.objects.zip_codes_for_the_usa);

	draw(data)
});

function draw(data) {


	var center = d3.geo.centroid(featureCollection)
	var scale  = 150;
	var offset = [width/2, height/2];
	var proj = d3.geo.mercator().scale(scale).center(center)
	.translate(offset);

		// create the path
		var path = d3.geo.path().projection(proj);

		// using the path determine the bounds of the current map and use 
		// these to determine better values for the scale and translation
		var bounds  = path.bounds(featureCollection);
		var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
		var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
		var scale   = (hscale < vscale) ? hscale : vscale;
		var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
		height - (bounds[0][1] + bounds[1][1])/2];

        // console.log(center, scale, offset)

		// new projection
		proj = d3.geo.mercator().center(center)
		.scale(scale).translate(offset);
		path = path.projection(proj);

		var paths = svg.selectAll("path")
		.data(featureCollection.features, function(d){
			return d.properties.zip;
		});

		paths.enter().append("path")
		.attr("d", path)
		.attr("fill", "red")
		.attr("opacity", 0);

		var size = 0;
		paths.transition().duration(500)
		.attr("fill", "rgba(102, 230, 172, 1)")
		.attr("opacity", function(d){
			if(d.properties.zip in nestedByZip) {
				size = size + 1;
				return colScale(nestedByZip[d.properties.zip]);
			}
			else {
				return 0.02;
			}
		})
		.delay(function(d, i){
			return i / size * 1000;
		})
		.duration(250);

		paths.on("mouseover", function(d){
			d3.select(this).transition().duration(50)
			.attr("opacity", function(d){
				if(d.properties.zip in nestedByZip) {
					return colScale(nestedByZip[d.properties.zip]) + .4;
				}
				else {
					return 0.02;
				}
			})
		});

		paths.on("mouseout", function(d){
			d3.select(this).transition().duration(800)
			.attr("opacity", function(d){
				if(d.properties.zip in nestedByZip) {
					return colScale(nestedByZip[d.properties.zip]);
				}
				else {
					return 0.02;
				}
			})
		});

		paths.exit().remove();	

	}


</script>